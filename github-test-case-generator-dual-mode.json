{
  "name": "GitHub Test Case Generator - Dual Mode (Batch & Individual)",
  "nodes": [
    {
      "parameters": {},
      "id": "2644759f-00a5-412c-b85e-a9ffba975cda",
      "name": "When clicking 'Test workflow'",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-3408, -272]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "owner",
              "value": "wizeline",
              "type": "string"
            },
            {
              "id": "2",
              "name": "repo",
              "value": "BytescribeTeam",
              "type": "string"
            },
            {
              "id": "3",
              "name": "branch",
              "value": "main",
              "type": "string"
            },
            {
              "id": "4",
              "name": "processingMode",
              "value": "batch",
              "type": "string"
            },
            {
              "id": "5",
              "name": "batchSize",
              "value": 10,
              "type": "number"
            },
            {
              "id": "6",
              "name": "fetchFileContent",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "7",
              "name": "maxFilesToProcess",
              "value": 10,
              "type": "number"
            },
            {
              "id": "8",
              "name": "testBranch",
              "value": "auto-generated-tests",
              "type": "string"
            },
            {
              "id": "9",
              "name": "excludePatterns",
              "value": "[\"node_modules\", \".test.\", \"_spec.\", \"__init__\", \"constants\", \"config\"]",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "e6ef4b42-cc3e-4487-9809-69d5031f82d8",
      "name": "Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-3184, -272],
      "notes": "Set processingMode to:\n- 'batch' for faster batch processing\n- 'individual' for detailed file-by-file analysis\n\nSet fetchFileContent to true to get actual code content\nAdjust maxFilesToProcess and batchSize as needed\ntestBranch: branch name for auto-generated test commits"
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/branches/{{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "ee4f8f6c-a1d9-4268-bd52-b54d1a33fb81",
      "name": "Get Branch Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-2960, -272],
      "credentials": {
        "githubApi": {
          "id": "8iyQGt8qXBNNlcup",
          "name": "GitHub account 4"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $('Configuration').item.json.owner }}/{{ $('Configuration').item.json.repo }}/git/trees/{{ $json.commit.sha }}?recursive=1",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "bb121676-b20a-4519-9315-b9acec1186ee",
      "name": "Get Repository Tree",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-2736, -272],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract file tree from GitHub API response\nconst treeData = $input.first().json.tree;\nconst config = $('Configuration').first().json;\nconst owner = config.owner;\nconst repo = config.repo;\nconst branch = config.branch;\nconst maxFiles = config.maxFilesToProcess || 100;\n\n// Define testable file extensions by language/framework\nconst testableExtensions = {\n  javascript: ['.js', '.jsx', '.mjs', '.cjs'],\n  typescript: ['.ts', '.tsx'],\n  python: ['.py'],\n  java: ['.java', '.kt', '.kts'],\n  csharp: ['.cs'],\n  go: ['.go'],\n  ruby: ['.rb'],\n  php: ['.php'],\n  rust: ['.rs'],\n  swift: ['.swift'],\n  cpp: ['.c', '.cpp', '.cc', '.cxx', '.h', '.hpp'],\n  scala: ['.scala'],\n  vue: ['.vue'],\n  svelte: ['.svelte']\n};\n\nconst allTestableExtensions = Object.values(testableExtensions).flat();\n\n// Enhanced exclusion: Paths and directories that contain test files\nconst excludePaths = [\n  'test', 'tests', '__tests__', 'spec', 'specs',\n  '__test__', '__spec__', 'testing',\n  'e2e', 'integration', 'unit',\n  'fixtures', 'mocks', '__mocks__',\n  'node_modules', 'vendor', 'dist', 'build', 'out',\n  '.git', '.github', '.vscode', '.idea',\n  'coverage', 'docs', 'documentation',\n  'examples', 'demo', 'samples'\n];\n\n// Enhanced exclusion: File name patterns commonly used for tests\nconst excludeFilenames = [\n  // Config files\n  'jest.config', 'webpack.config', 'babel.config',\n  'tsconfig', 'eslint', 'prettier', 'vitest.config',\n  'karma.config', 'mocha.config', 'jasmine.config',\n  // Test file patterns - middle of filename\n  '.test.', '.spec.', '_test.', '_spec.',\n  '.tests.', '.specs.', '_tests.', '_specs.',\n  // Test file patterns - start of filename\n  'test.', 'spec.', 'test_', 'spec_',\n  // Test file patterns - end of filename (before extension)\n  'test', 'spec', 'tests', 'specs',\n  // Mock and fixture patterns\n  'mock', 'mocks', '.mock.', '_mock.',\n  'fixture', 'fixtures', '.fixture.', '_fixture.',\n  'stub', 'stubs', '.stub.', '_stub.',\n  // Setup and helper test files\n  'setup', 'testsetup', 'test-setup', 'test_setup',\n  'helper', 'testhelper', 'test-helper', 'test_helper',\n  // Framework-specific patterns\n  'testcase', 'test-case', 'test_case',\n  'unittest', 'unit-test', 'unit_test'\n];\n\nconst sourceFiles = treeData\n  .filter(item => {\n    if (item.type !== 'blob') return false;\n    \n    const path = item.path.toLowerCase();\n    const filename = path.split('/').pop();\n    const filenameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;\n    \n    // Must have a testable extension\n    const hasTestableExt = allTestableExtensions.some(ext => \n      item.path.endsWith(ext)\n    );\n    if (!hasTestableExt) return false;\n    \n    // Exclude files in test-related directories\n    const isInExcludedPath = excludePaths.some(excluded => \n      path.includes('/' + excluded.toLowerCase() + '/') || \n      path.startsWith(excluded.toLowerCase() + '/')\n    );\n    if (isInExcludedPath) return false;\n    \n    // Exclude files with test-related patterns in filename\n    const hasExcludedPattern = excludeFilenames.some(pattern => \n      filename.includes(pattern.toLowerCase())\n    );\n    if (hasExcludedPattern) return false;\n    \n    // Additional check: filename ends with test/spec pattern (before extension)\n    // e.g., user.test.js, api.spec.ts, myfile_test.py\n    const testSuffixPatterns = ['test', 'spec', 'tests', 'specs'];\n    const endsWithTestPattern = testSuffixPatterns.some(suffix => {\n      // Check if filename (without extension) ends with these patterns\n      return filenameWithoutExt.endsWith('.' + suffix) || \n             filenameWithoutExt.endsWith('_' + suffix) || \n             filenameWithoutExt.endsWith('-' + suffix);\n    });\n    if (endsWithTestPattern) return false;\n    \n    // Additional check: filename starts with test/spec pattern\n    // e.g., test_user.py, spec_api.js\n    const startsWithTestPattern = testSuffixPatterns.some(prefix => {\n      return filenameWithoutExt.startsWith(prefix + '.') || \n             filenameWithoutExt.startsWith(prefix + '_') || \n             filenameWithoutExt.startsWith(prefix + '-');\n    });\n    if (startsWithTestPattern) return false;\n    \n    // Exclude very large files\n    if (item.size && item.size > 500000) return false;\n    \n    return true;\n  })\n  .slice(0, maxFiles)  // Limit based on config\n  .map(file => {\n    let language = 'unknown';\n    for (const [lang, exts] of Object.entries(testableExtensions)) {\n      if (exts.some(ext => file.path.endsWith(ext))) {\n        language = lang;\n        break;\n      }\n    }\n    \n    return {\n      path: file.path,\n      sha: file.sha,\n      size: file.size,\n      url: file.url,\n      language: language,\n      owner: owner,\n      repo: repo,\n      branch: branch\n    };\n  });\n\nconst filesByLanguage = sourceFiles.reduce((acc, file) => {\n  if (!acc[file.language]) {\n    acc[file.language] = [];\n  }\n  acc[file.language].push(file);\n  return acc;\n}, {});\n\nconst languageStats = Object.entries(filesByLanguage).map(([lang, files]) => ({\n  language: lang,\n  count: files.length,\n  totalSize: files.reduce((sum, f) => sum + (f.size || 0), 0)\n}));\n\nreturn [{\n  json: {\n    owner,\n    repo,\n    branch,\n    processingMode: config.processingMode,\n    fetchFileContent: config.fetchFileContent,\n    batchSize: config.batchSize,\n    totalFiles: treeData.length,\n    sourceFilesCount: sourceFiles.length,\n    sourceFiles: sourceFiles,\n    filesByLanguage: filesByLanguage,\n    languageStats: languageStats,\n    repositoryUrl: `https://github.com/${owner}/${repo}`\n  }\n}];"
      },
      "id": "5adaaa94-68a6-4f50-bfc1-8d9ad9c430fa",
      "name": "Process File Structure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2512, -272]
    },
    {
      "parameters": {
        "jsCode": "// Apply user-configured exclude patterns to the discovered sourceFiles\nconst repo = $('Process File Structure').first().json || {};\nconst config = $('Configuration').first().json || {};\n\n// Parse patterns (supports JSON array string, comma-separated string, and regex via 're:pattern' or '/pattern/flags')\nlet rawPatterns = [];\ntry {\n  const raw = config.excludePatterns;\n  if (Array.isArray(raw)) rawPatterns = raw;\n  else if (typeof raw === 'string') {\n    const s = raw.trim();\n    if (s.startsWith('[')) {\n      try { rawPatterns = JSON.parse(s); } catch (e) { rawPatterns = s.split(','); }\n    } else {\n      rawPatterns = s.split(',');\n    }\n  }\n} catch (e) { rawPatterns = []; }\n\nconst patterns = rawPatterns.map(p => {\n  try {\n    if (typeof p !== 'string') p = String(p);\n    const pp = p.trim();\n    if (!pp) return null;\n    // regex with re: prefix\n    if (pp.startsWith('re:')) {\n      try { return { type: 'regex', re: new RegExp(pp.slice(3), 'i') }; } catch (e) { return { type: 'string', value: pp.slice(3).toLowerCase() }; }\n    }\n    // regex with /.../flags style\n    if (pp.startsWith('/') && pp.lastIndexOf('/') > 0) {\n      const last = pp.lastIndexOf('/');\n      const body = pp.slice(1, last);\n      const flags = pp.slice(last + 1) || 'i';\n      try { return { type: 'regex', re: new RegExp(body, flags.includes('i') ? flags : flags + 'i') }; } catch (e) { return { type: 'string', value: pp.toLowerCase() }; }\n    }\n    return { type: 'string', value: pp.toLowerCase() };\n  } catch (e) { return null; }\n}).filter(Boolean);\n\nfunction matchesPattern(filePath, filename, filenameNoExt) {\n  if (!patterns || patterns.length === 0) return false;\n  for (const p of patterns) {\n    if (!p) continue;\n    if (p.type === 'regex') {\n      try {\n        if (p.re.test(filePath) || p.re.test(filename) || p.re.test(filenameNoExt)) return true;\n      } catch (e) { continue; }\n    } else {\n      if ((filePath || '').includes(p.value) || (filename || '').includes(p.value) || (filenameNoExt || '').includes(p.value)) return true;\n    }\n  }\n  return false;\n}\n\nconst originalFiles = repo.sourceFiles || [];\nconst filtered = originalFiles.filter(f => {\n  const path = (f.path || '').toLowerCase();\n  const filename = path.split('/').pop() || '';\n  const filenameNoExt = filename.indexOf('.') > -1 ? filename.substring(0, filename.lastIndexOf('.')) : filename;\n  return !matchesPattern(path, filename, filenameNoExt);\n});\n\nconst filesByLanguage = filtered.reduce((acc, file) => { if (!acc[file.language]) acc[file.language] = []; acc[file.language].push(file); return acc; }, {});\nconst languageStats = Object.entries(filesByLanguage).map(([lang, files]) => ({ language: lang, count: files.length, totalSize: files.reduce((s, f) => s + (f.size || 0), 0) }));\n\nreturn [{ json: { ...repo, sourceFilesCount: filtered.length, sourceFiles: filtered, filesByLanguage: filesByLanguage, languageStats: languageStats } }];"
      },
      "id": "37e94bc9-a389-4981-92cf-30f85d80527a",
      "name": "Apply Exclude Patterns",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2288, -272]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "mode-check",
              "leftValue": "={{ $json.processingMode }}",
              "rightValue": "individual",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "37f138f8-d81b-4deb-a094-c6a396492cd6",
      "name": "Route by Processing Mode",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-2064, -272]
    },
    {
      "parameters": {
        "fieldToSplitOut": "sourceFiles",
        "options": {}
      },
      "id": "0c3ba20f-d0b7-494a-a7ce-51c89ea8e9d4",
      "name": "Split Into Individual Files",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [-1840, -472]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/contents/{{ $json.path }}?ref={{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "1cd77d9f-c94c-40cd-a9f2-e53552de646a",
      "name": "Fetch File Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-1616, -472],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Decode base64 content and prepare for AI\nconst item = $input.first().json;\nconst fileInfo = $input.first().json;\n\nlet fileContent = '';\nif (item.content && item.encoding === 'base64') {\n  fileContent = Buffer.from(item.content, 'base64').toString('utf-8');\n}\n\nreturn [{\n  json: {\n    filePath: item.path,\n    fileName: item.name,\n    language: fileInfo.language,\n    size: item.size,\n    content: fileContent,\n    sha: item.sha,\n    owner: fileInfo.owner,\n    repo: fileInfo.repo\n  }\n}];"
      },
      "id": "ca34ccbd-7740-4819-b1f3-6eed36842597",
      "name": "Prepare Individual File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1392, -472]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "individual-prompt",
              "name": "prompt",
              "value": "=File: {{ $json.filePath }}\nLanguage: {{ $json.language }}\nSize: {{ $json.size }} bytes\n\nFile Content:\n```{{ $json.language }}\n{{ $json.content }}\n```\n\nTask: Generate COMPLETE, EXECUTABLE unit tests for this file. The tests must be production-ready code that can run immediately.\n\nRequirements:\n1. Analyze all functions, classes, and exports in the source file\n2. Generate FULL test code with proper imports, setup, and teardown\n3. Cover happy paths, edge cases, error handling, and boundary conditions\n4. Use appropriate testing framework for {{ $json.language }}\n5. Include necessary mocks for external dependencies\n6. Write tests that actually validate the logic in the source code\n7. Generate COMPLETE test file content - no placeholders or comments like \"add more tests\"\n\nIMPORTANT: Return ONLY valid JSON, no markdown or explanations.\n\nFormat:\n{\n  \"sourceFile\": \"{{ $json.filePath }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"testFile\": \"path/to/test/file\",\n  \"framework\": \"jest|mocha|pytest|junit|etc\",\n  \"testFileContent\": \"COMPLETE executable test code with all imports and test cases\",\n  \"dependencies\": [\"testing-library\", \"mock-library\"],\n  \"coverage\": {\n    \"functions\": [\"function1\", \"function2\"],\n    \"scenarios\": [\"happy path\", \"error cases\", \"edge cases\"]\n  },\n  \"runCommand\": \"command to execute tests\",\n  \"notes\": \"Setup instructions if needed\"\n}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "58762b2d-a854-4150-a8c5-77b4e64d4255",
      "name": "Prepare Individual File Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-1168, -472]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {}
      },
      "id": "dca7f7dc-d9c1-49b1-9d0a-3d8602a50998",
      "name": "AI - Individual File Analysis",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [-944, -576]
    },
    {
      "parameters": {},
      "id": "98e86700-f299-40be-b252-5ea56b8253a3",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [-592, -272]
    },
    {
      "parameters": {
        "jsCode": "// Prepare batch processing\nconst data = $input.first().json;\nconst batchSize = data.batchSize || 10;\nconst sourceFiles = data.sourceFiles;\n\n// Create batches\nconst batches = [];\nfor (let i = 0; i < sourceFiles.length; i += batchSize) {\n  batches.push({\n    batchNumber: Math.floor(i / batchSize) + 1,\n    files: sourceFiles.slice(i, i + batchSize),\n    owner: data.owner,\n    repo: data.repo,\n    branch: data.branch,\n    totalBatches: Math.ceil(sourceFiles.length / batchSize)\n  });\n}\n\nreturn batches.map(batch => ({ json: batch }));"
      },
      "id": "b844bd04-3df4-405f-884d-611dbdcaf02f",
      "name": "Create Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1392, -72]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "batch-prompt",
              "name": "batchPrompt",
              "value": "=Batch {{ $json.batchNumber }}/{{ $json.totalBatches }}\nRepository: {{ $json.owner }}/{{ $json.repo }}\n\nFiles in this batch ({{ $json.files.length }} files):\n{{ $json.files.map(f => `- ${f.path} [${f.language}] (${f.size} bytes)`).join('\\n') }}\n\nTask: Generate COMPLETE, EXECUTABLE unit tests for EACH file listed above. You MUST generate {{ $json.files.length }} separate test objects - one for each file.\n\nFor each file:\n1. Infer the likely content and structure based on the file path and language\n2. Generate FULL test code with proper imports, setup, and teardown\n3. Cover common scenarios for files of this type\n4. Use appropriate testing framework\n5. Include necessary mocks\n6. Write COMPLETE test file content - no placeholders\n\nCRITICAL: You must return a JSON array with EXACTLY {{ $json.files.length }} objects - one for each file. Do not combine multiple files into one test.\n\nIMPORTANT: Return ONLY a valid JSON array with complete test code.\n\nFormat (repeat for each file):\n[\n  {\n    \"sourceFile\": \"exact/path/from/list/above\",\n    \"language\": \"language\",\n    \"testFile\": \"path/to/test/file\",\n    \"framework\": \"jest|pytest|junit|etc\",\n    \"testFileContent\": \"COMPLETE executable test code for this specific file\",\n    \"dependencies\": [\"test-deps\"],\n    \"coverage\": {\n      \"functions\": [\"assumed functions\"],\n      \"scenarios\": [\"scenarios covered\"]\n    },\n    \"runCommand\": \"command to run tests\",\n    \"notes\": \"Any setup notes\"\n  },\n  ... ({{ $json.files.length - 1 }} more objects)\n]",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "a382ab4f-b171-4729-807e-debe528ec5c2",
      "name": "Prepare Batch Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-1168, -72]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.batchPrompt }}",
        "options": {}
      },
      "id": "79017688-857d-4352-b018-75b4c57c6bf1",
      "name": "AI - Batch Analysis",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [-944, -72]
    },
    {
      "parameters": {
        "jsCode": "// Parse and aggregate batch results\nconst items = $input.all();\nconst repoInfo = $('Apply Exclude Patterns').first().json;\n\nlet allTestCases = [];\nlet failedItems = [];\n\n// Helper function to convert JS template literals and Python triple quotes to valid JSON\nfunction normalizeToJSON(str) {\n  let normalized = str;\n  \n  // Remove markdown code fences\n  normalized = normalized.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  \n  // Find the array or object structure\n  const arrayMatch = normalized.match(/\\[\\s*{[\\s\\S]*}\\s*\\]/);\n  const targetStr = arrayMatch ? arrayMatch[0] : normalized;\n  \n  // Replace template literals (`...`) with proper JSON strings\n  // This regex finds backtick strings and converts them to double-quoted strings\n  let result = targetStr.replace(/`([^`]*)`/gs, (match, content) => {\n    // Escape special JSON characters in the content\n    const escaped = content\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t');\n    return `\"${escaped}\"`;\n  });\n  \n  // Replace Python triple-quoted strings (\"\"\"...\"\"\") with proper JSON strings\n  result = result.replace(/\"\"\"([^\"]*)?\"\"\"/gs, (match, content) => {\n    const escaped = content\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t');\n    return `\"${escaped}\"`;\n  });\n  \n  // Remove trailing commas before closing braces/brackets\n  result = result.replace(/,\\s*([\\]}])/g, '$1');\n  \n  // Ensure property names are double-quoted\n  result = result.replace(/([{,]\\s*)([a-zA-Z_][a-zA-Z0-9_]*)\\s*:/g, '$1\"$2\":');\n  \n  return result;\n}\n\nitems.forEach((item, itemIndex) => {\n  let output = item.json.output;\n  \n  let testCases;\n  try {\n    // If already an object, use it directly\n    if (typeof output === 'object' && output !== null) {\n      testCases = output;\n    } else if (typeof output === 'string') {\n      // Strategy 1: Try direct JSON parse\n      try {\n        testCases = JSON.parse(output);\n      } catch (parseError) {\n        // Strategy 2: Normalize template literals and triple quotes, then parse\n        try {\n          const normalized = normalizeToJSON(output);\n          testCases = JSON.parse(normalized);\n        } catch (normalizeError) {\n          // Strategy 3: Try to use eval as last resort for JS object literals\n          try {\n            // Extract just the array/object part\n            let cleaned = output.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n            const arrayMatch = cleaned.match(/\\[\\s*{[\\s\\S]*}\\s*\\]/);\n            if (arrayMatch) {\n              // Wrap in parentheses and eval to parse JS object literal\n              testCases = eval(`(${arrayMatch[0]})`);\n            } else {\n              const objectMatch = cleaned.match(/{[\\s\\S]*}/);\n              if (objectMatch) {\n                testCases = eval(`(${objectMatch[0]})`);\n              } else {\n                throw new Error('No valid JSON or JS object pattern found');\n              }\n            }\n          } catch (evalError) {\n            console.error(`Failed to parse item ${itemIndex}:`, evalError.message);\n            failedItems.push({ \n              itemIndex, \n              error: evalError.message, \n              output: output.substring(0, 500),\n              parseAttempts: ['JSON.parse', 'normalizeToJSON', 'eval']\n            });\n            testCases = [];\n          }\n        }\n      }\n    } else {\n      testCases = [];\n    }\n  } catch (e) {\n    console.error(`Error processing item ${itemIndex}:`, e.message);\n    failedItems.push({ itemIndex, error: e.message });\n    testCases = [];\n  }\n  \n  // Ensure testCases is an array\n  if (!Array.isArray(testCases)) {\n    testCases = testCases ? [testCases] : [];\n  }\n  \n  allTestCases = allTestCases.concat(testCases);\n});\n\nconst formattedOutput = {\n  repository: {\n    owner: repoInfo.owner,\n    repo: repoInfo.repo,\n    branch: repoInfo.branch,\n    url: repoInfo.repositoryUrl\n  },\n  processingMode: repoInfo.processingMode,\n  summary: {\n    totalSourceFiles: repoInfo.sourceFilesCount,\n    filesAnalyzed: allTestCases.length,\n    generatedAt: new Date().toISOString(),\n    batchesProcessed: items.length,\n    failedItems: failedItems.length,\n    successfulItems: items.length - failedItems.length\n  },\n  testFiles: allTestCases.map((tc, index) => ({\n    id: index + 1,\n    sourceFile: tc.sourceFile,\n    testFile: tc.testFile,\n    framework: tc.framework || 'jest',\n    language: tc.language,\n    testFileContent: tc.testFileContent || '',\n    dependencies: tc.dependencies || [],\n    coverage: tc.coverage || {},\n    runCommand: tc.runCommand || '',\n    notes: tc.notes || ''\n  })),\n  errors: failedItems.length > 0 ? failedItems : undefined\n};\n\nreturn [{ json: formattedOutput }];"
      },
      "id": "4ac2a488-055c-4e95-9898-8018cf162ce8",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-368, -272]
    },
    {
      "parameters": {
        "operation": "toJson",
        "options": {
          "fileName": "=github-test-cases-{{ $json.repository.repo }}-{{ $json.processingMode }}-{{ $now.format('yyyy-MM-dd-HHmmss') }}.json"
        }
      },
      "id": "cd396e3d-817b-491a-ba59-4cc31b9a7d24",
      "name": "Export to JSON File",
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [-144, -368]
    },
    {
      "parameters": {
        "jsCode": "// Attach repository context and prepare branch check\nconst formatted = $input.first().json;\nconst repo = formatted.repository || {};\nconst config = $('Configuration').first().json;\nconst testFiles = formatted.testFiles || [];\nconst enriched = testFiles.map(tf => ({ ...tf, owner: tf.owner || repo.owner, repo: tf.repo || repo.repo, branch: tf.branch || repo.branch }));\n\nreturn [{ json: { \n  testFiles: enriched,\n  owner: repo.owner,\n  repo: repo.repo,\n  testBranch: config.testBranch,\n  sourceBranch: config.branch,\n  checkBranchUrl: `https://api.github.com/repos/${repo.owner}/${repo.repo}/branches/${config.testBranch}`\n} }];"
      },
      "id": "193345eb-023b-4203-b4f5-1ffc8300e159",
      "name": "Attach Repo Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-144, -176]
    },
    {
      "parameters": {
        "url": "={{ $json.checkBranchUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {
          "allowUnauthorizedCerts": false
        }
      },
      "id": "f2274763-5850-4f35-ad85-18a3a700be68",
      "name": "Check Test Branch Once",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [80, -176],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Check if branch exists\nconst branchCheckResult = $input.first().json;\nconst repoContext = $('Attach Repo Context').first().json;\n\nconst hasError = branchCheckResult.error !== undefined;\nconst statusCode = branchCheckResult.statusCode || (hasError ? 404 : 200);\nconst branchExists = !hasError && statusCode === 200;\n\nreturn [{\n  json: {\n    ...repoContext,\n    branchExists: branchExists,\n    statusCode: statusCode\n  }\n}];"
      },
      "id": "b891925a-2499-4c03-a01e-3d6537d51f50",
      "name": "Process Branch Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [304, -176]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "branch-exists-global",
              "leftValue": "={{ $json.branchExists }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "4be4a553-1022-4108-b7a3-5b4c30263efe",
      "name": "Need to Create Branch?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [528, -176]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/ref/heads/{{ $json.sourceBranch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "5ea164e1-3283-4adb-9339-6ed65a9448f3",
      "name": "Get Source SHA Once",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [752, -272],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.github.com/repos/{{ $('Process Branch Check').first().json.owner }}/{{ $('Process Branch Check').first().json.repo }}/git/refs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ ref: 'refs/heads/' + $('Process Branch Check').first().json.testBranch, sha: $json.object.sha }) }}",
        "options": {}
      },
      "id": "4c00da6c-de94-470c-b99c-f1cf0eac428f",
      "name": "Create Branch Once",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [976, -272],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pass through the test files for splitting\nconst repoContext = $('Process Branch Check').first().json;\nreturn [{ json: repoContext }];"
      },
      "id": "4527c6fe-6771-4b27-bbf3-663430ce3219",
      "name": "Pass Through After Creation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, -272]
    },
    {
      "parameters": {
        "jsCode": "// Pass through the test files for splitting (branch already exists)\nconst repoContext = $input.first().json;\nreturn [{ json: repoContext }];"
      },
      "id": "f6d07ee8-9649-49ea-9825-3d5fff746a6b",
      "name": "Pass Through Existing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, -80]
    },
    {
      "parameters": {},
      "id": "b5a8a8a9-b155-46e3-b67a-a11ab1c7d167",
      "name": "Merge Branch Ready",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1424, -176]
    },
    {
      "parameters": {
        "jsCode": "// Debug: Check testFiles array before split\nconst item = $input.first().json;\nconsole.log('=== BEFORE SPLIT DEBUG ===');\nconsole.log('Has testFiles:', !!item.testFiles);\nconsole.log('testFiles is array:', Array.isArray(item.testFiles));\nconsole.log('testFiles length:', item.testFiles ? item.testFiles.length : 0);\nif (item.testFiles && item.testFiles.length > 0) {\n  console.log('First test file:', item.testFiles[0].sourceFile);\n  console.log('Last test file:', item.testFiles[item.testFiles.length - 1].sourceFile);\n}\nreturn $input.all();"
      },
      "id": "4a0a6c87-b6e7-4e91-97a8-ad7915c1a353",
      "name": "Debug Before Split",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1648, -176]
    },
    {
      "parameters": {
        "fieldToSplitOut": "testFiles",
        "options": {}
      },
      "id": "29a967c1-ecee-4b48-be28-6e734a9daf01",
      "name": "Split Test Files",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [1872, -176]
    },
    {
      "parameters": {
        "jsCode": "// Debug: Log what we received after split - process ALL items\nconst items = $input.all();\nconsole.log('=== SPLIT ITEM DEBUG ===');\nconsole.log('Total items after split:', items.length);\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i].json;\n  console.log(`\\n--- Item ${i + 1} ---`);\n  console.log('Item keys:', Object.keys(item));\n  console.log('Source file:', item.sourceFile);\n  console.log('Test file:', item.testFile);\n  console.log('Has testFileContent:', !!item.testFileContent);\n  console.log('Content length:', item.testFileContent ? item.testFileContent.length : 0);\n}\n\n// Return ALL items\nreturn items;"
      },
      "id": "c21672e8-9032-48a2-ae55-e2c7ebc67a59",
      "name": "Debug Split Item",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2096, -176]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "data",
              "value": "={{ $json.testFileContent }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "78f1a1fa-1290-4efd-9e98-d95b7aebf5d5",
      "name": "Prepare Test File Content",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [2320, -176]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare commit payload for GitHub - process current item\nconst item = $input.item.json || {};\nconst content = item.testFileContent || item.data || '';\nconst config = $('Configuration').first().json;\n\n// Helper function to extract component/module name from test content\nfunction extractSourceNameFromContent(content, language) {\n  if (!content) return null;\n  \n  // For JavaScript/TypeScript: look for import statements or describe blocks\n  if (language === 'javascript' || language === 'typescript' || !language) {\n    // Try to find: import ComponentName from '...'\n    const importMatch = content.match(/import\\s+(\\w+)\\s+from\\s+['\"][^'\"]+['\"]/m);\n    if (importMatch && importMatch[1] && importMatch[1] !== 'React' && importMatch[1] !== 'pytest') {\n      return importMatch[1];\n    }\n    \n    // Try to find: describe('ComponentName', ...)\n    const describeMatch = content.match(/describe\\(['\"]([\\w]+)['\"]/m);\n    if (describeMatch && describeMatch[1]) {\n      return describeMatch[1];\n    }\n  }\n  \n  // For Python: look for import statements or class/function names\n  if (language === 'python') {\n    // Try to find: from module.submodule import ClassName\n    const fromImportMatch = content.match(/from\\s+[\\w.]+\\s+import\\s+(\\w+)/m);\n    if (fromImportMatch && fromImportMatch[1] && fromImportMatch[1] !== '*') {\n      return fromImportMatch[1];\n    }\n    \n    // Try to find: import module.ClassName\n    const importMatch = content.match(/import\\s+([\\w.]+)/m);\n    if (importMatch && importMatch[1]) {\n      const parts = importMatch[1].split('.');\n      return parts[parts.length - 1];\n    }\n  }\n  \n  return null;\n}\n\n// Determine the target path and filename\nlet targetPath = '';\nlet sourceFile = item.sourceFile || '';\nconst language = item.language || 'javascript';\n\n// Check if sourceFile looks like a generated test file (contains 'generated_test_')\nconst isGeneratedTestName = sourceFile && sourceFile.includes('generated_test_');\n\n// If sourceFile is empty or looks like a generated test name, try to extract real source from content\nif (!sourceFile || !sourceFile.trim() || isGeneratedTestName) {\n  const extractedName = extractSourceNameFromContent(content, language);\n  if (extractedName) {\n    // Build a reasonable source file path based on extracted name\n    if (language === 'python') {\n      sourceFile = extractedName.toLowerCase() + '.py';\n    } else if (language === 'typescript') {\n      sourceFile = extractedName + '.tsx';\n    } else {\n      sourceFile = extractedName + '.js';\n    }\n  } else if (isGeneratedTestName) {\n    // If extraction failed but we have a generated name, keep it as fallback\n    // (this maintains current behavior for truly unidentifiable files)\n  }\n}\n\n// Strategy 1: Use testFile if provided by AI (already includes full path)\nif (item.testFile && item.testFile.trim() && !item.testFile.includes('generated_test_')) {\n  targetPath = item.testFile;\n  // Extract sourceFile from testFile if not provided\n  if (!sourceFile) {\n    const testFileName = targetPath.split('/').pop();\n    sourceFile = testFileName.replace(/\\.(test|spec)/, '').replace(/^test[_-]/, '');\n  }\n} \n// Strategy 2: Build from sourceFile\nelse if (sourceFile && sourceFile.trim()) {\n  const pathParts = sourceFile.split('/');\n  const fileName = pathParts[pathParts.length - 1];\n  \n  // Determine test file extension based on language or source extension\n  const sourceExt = fileName.substring(fileName.lastIndexOf('.'));\n  \n  // Map languages to test file extensions\n  const testExtMap = {\n    'typescript': '.test.ts',\n    'javascript': '.test.js',\n    'python': '_test.py',\n    'java': 'Test.java',\n    'go': '_test.go',\n    'ruby': '_spec.rb',\n    'php': 'Test.php'\n  };\n  \n  let testExt = testExtMap[language] || '.test' + sourceExt;\n  \n  // For TypeScript/JavaScript React files\n  if (sourceExt === '.tsx') testExt = '.test.tsx';\n  else if (sourceExt === '.jsx') testExt = '.test.jsx';\n  else if (sourceExt === '.ts') testExt = '.test.ts';\n  else if (sourceExt === '.js') testExt = '.test.js';\n  else if (sourceExt === '.py') testExt = '_test.py';\n  \n  // Remove original extension and add test suffix\n  const dotIndex = fileName.lastIndexOf('.');\n  const nameWithoutExt = dotIndex > 0 ? fileName.substring(0, dotIndex) : fileName;\n  \n  // Build test filename\n  let testFileName;\n  if (language === 'python') {\n    testFileName = `test_${nameWithoutExt}.py`;\n  } else if (language === 'java') {\n    testFileName = `${nameWithoutExt}Test.java`;\n  } else {\n    testFileName = `${nameWithoutExt}${testExt}`;\n  }\n  \n  // Build full path: tests/auto-generated/{language}/{testFileName}\n  targetPath = `tests/auto-generated/${language}/${testFileName}`;\n} \n// Strategy 3: Generate unique filename as fallback\nelse {\n  const timestamp = Date.now();\n  const randomSuffix = Math.random().toString(36).substring(2, 15);\n  const ext = language === 'python' ? '.py' : language === 'typescript' ? '.ts' : '.js';\n  const testFileName = `generated_test_${timestamp}_${randomSuffix}${ext}`;\n  targetPath = `tests/auto-generated/${language}/${testFileName}`;\n  sourceFile = testFileName;\n}\n\n// Base64 encode the content\nconst contentBase64 = Buffer.from(content, 'utf8').toString('base64');\n\n// Get owner/repo from item\nconst owner = item.owner || config.owner || 'unknown-owner';\nconst repo = item.repo || config.repo || 'unknown-repo';\nconst branch = config.testBranch;  // Use test branch directly\n\n// Extract filename for commit message and local export\nconst pathParts = targetPath.split('/');\nconst localFileName = pathParts[pathParts.length - 1];\nconst commitMessage = `chore(tests): add auto-generated test for ${sourceFile || localFileName}`;\n\n// Return data for both GitHub commit and local file creation\nreturn { json: { owner, repo, branch, targetPath, contentBase64, commitMessage, testFile: targetPath, testFileContent: content, data: content, localFileName, sourceFile } };"
      },
      "id": "0f4db90f-2985-48c0-ab78-f4b9155a380a",
      "name": "Prepare Git Commit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2544, -176]
    },
    {
      "parameters": {
        "jsCode": "// Preserve commit data and prepare for branch check\nconst commitData = $input.first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...commitData,\n    testBranch: config.testBranch,\n    checkBranchUrl: `https://api.github.com/repos/${commitData.owner}/${commitData.repo}/branches/${config.testBranch}`\n  }\n}];"
      },
      "id": "a4f98953-4374-4110-aa41-2e7a115512ca",
      "name": "Preserve Commit Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [752, 208]
    },
    {
      "parameters": {
        "url": "={{ $json.checkBranchUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {
          "allowUnauthorizedCerts": false
        }
      },
      "id": "08c4a31f-cd1b-4052-87c3-4fdd07e23e6e",
      "name": "Check If Test Branch Exists",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [976, 208],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Merge the branch check result with commit data\nconst branchCheckResult = $input.first().json;\nconst commitData = $('Preserve Commit Data').first().json;\n\n// Check if the request failed (error property exists) or succeeded\nconst hasError = branchCheckResult.error !== undefined;\nconst statusCode = branchCheckResult.statusCode || (hasError ? 404 : 200);\nconst branchExists = !hasError && statusCode === 200;\n\nreturn [{\n  json: {\n    ...commitData,\n    branchExists: branchExists,\n    statusCode: statusCode\n  }\n}];"
      },
      "id": "848d5dea-117d-4670-9741-bca801247649",
      "name": "Merge Branch Check Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 208]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "branch-exists-check",
              "leftValue": "={{ $json.branchExists }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "f8d11672-6cfa-4133-8d2f-8f41f35d1b01",
      "name": "Branch Exists?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1424, 208]
    },
    {
      "parameters": {
        "jsCode": "// Get the latest commit SHA from the main branch to create new branch from it\nconst data = $input.first().json;\nconst prepareCommitData = $('Prepare Git Commit').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    owner: prepareCommitData.owner,\n    repo: prepareCommitData.repo,\n    sourceBranch: config.branch,\n    testBranch: config.testBranch,\n    ...prepareCommitData\n  }\n}];"
      },
      "id": "1522a312-04f4-4cac-9b10-bf3b0183eb68",
      "name": "Prepare Branch Creation Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1648, 112]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/ref/heads/{{ $json.sourceBranch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "8b00feaa-2641-49d8-9189-928ac0530e72",
      "name": "Get Source Branch SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1872, 112],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.github.com/repos/{{ $('Prepare Branch Creation Data').first().json.owner }}/{{ $('Prepare Branch Creation Data').first().json.repo }}/git/refs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ ref: 'refs/heads/' + $('Prepare Branch Creation Data').first().json.testBranch, sha: $json.object.sha }) }}",
        "options": {}
      },
      "id": "9d7215d5-79a1-4065-be6f-2fe5a4fed5d1",
      "name": "Create Test Branch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2096, 112],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge the branch creation result with the commit data\nconst prepareCommitData = $('Prepare Git Commit').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...prepareCommitData,\n    branch: config.testBranch  // Override branch to use test branch\n  }\n}];"
      },
      "id": "5b534cd9-c4d8-4fd3-ba74-d40a6b9ce2f8",
      "name": "Set Test Branch for Commit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2320, 112]
    },
    {
      "parameters": {
        "jsCode": "// For existing branch, just pass through with test branch override\nconst prepareCommitData = $('Preserve Commit Data').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...prepareCommitData,\n    branch: config.testBranch  // Override branch to use test branch\n  }\n}];"
      },
      "id": "0a5eabab-7014-4c65-854c-1dd19d8c0038",
      "name": "Use Existing Test Branch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2320, 304]
    },
    {
      "parameters": {},
      "id": "026c2dcf-9ed6-41a0-a4ac-fd31944fb6b6",
      "name": "Merge Branch Paths",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [2544, 208]
    },
    {
      "parameters": {
        "jsCode": "// Collect all test files and prepare for bulk commit using GitHub Tree API\nconst items = $input.all();\n\nconsole.log('=== AGGREGATE ALL TEST FILES DEBUG ===');\nconsole.log('Total items received:', items.length);\n\nif (items.length === 0) {\n  throw new Error('No items to commit');\n}\n\nconst firstItem = items[0].json;\nconsole.log('First item keys:', Object.keys(firstItem));\nconsole.log('First item owner:', firstItem.owner);\nconsole.log('First item targetPath:', firstItem.targetPath);\nconsole.log('First item has contentBase64:', !!firstItem.contentBase64);\n\n// Group files by owner/repo/branch\nconst owner = firstItem.owner;\nconst repo = firstItem.repo;\nconst branch = firstItem.branch;\n\n// Prepare tree entries for all files\nconst treeEntries = items.map((item, index) => {\n  const data = item.json;\n  console.log(`Item ${index}: path=${data.targetPath}, hasContent=${!!data.contentBase64}`);\n  \n  // Decode base64 content to UTF-8 for GitHub API\n  const content = data.contentBase64 \n    ? Buffer.from(data.contentBase64, 'base64').toString('utf-8')\n    : data.testFileContent || data.data || '';\n  \n  return {\n    path: data.targetPath,\n    mode: '100644',  // Regular file\n    type: 'blob',\n    content: content\n  };\n});\n\nconst commitMessage = `chore(tests): add ${items.length} auto-generated test files\\n\\nGenerated tests for:\\n${items.map(item => `- ${item.json.localFileName || item.json.sourceFile || 'unknown'}`).join('\\n')}`;\n\nconsole.log('Commit message:', commitMessage);\nconsole.log('Tree entries count:', treeEntries.length);\n\nreturn [{\n  json: {\n    owner,\n    repo,\n    branch,\n    treeEntries,\n    commitMessage,\n    fileCount: items.length,\n    files: items.map(item => item.json.targetPath)\n  }\n}];"
      },
      "id": "c91f9eb9-041c-4380-ab71-5fc10465b45f",
      "name": "Aggregate All Test Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2768, 16]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/ref/heads/{{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "ad1f6cff-ffaf-4083-9d9d-ac22672d9180",
      "name": "Get Branch Reference",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2992, 16],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract base tree SHA from branch reference\nconst response = $input.first().json;\nconst commitData = $('Aggregate All Test Files').first().json;\n\nreturn [{\n  json: {\n    ...commitData,\n    baseCommitSha: response.object.sha\n  }\n}];"
      },
      "id": "5f66751d-af34-49c8-ba52-d6f83397fa95",
      "name": "Extract Base Commit SHA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3216, 16]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/commits/{{ $json.baseCommitSha }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "4f75144b-451a-4b73-b5a4-cc06a784140a",
      "name": "Get Base Tree",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3440, 16],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract tree SHA and prepare for creating new tree\nconst commitInfo = $input.first().json;\nconst bulkData = $('Extract Base Commit SHA').first().json;\n\nreturn [{\n  json: {\n    ...bulkData,\n    baseTreeSha: commitInfo.tree.sha\n  }\n}];"
      },
      "id": "cc9a23fb-31de-4131-b4b9-cfb9603094cb",
      "name": "Extract Tree SHA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3664, 16]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/trees",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ base_tree: $json.baseTreeSha, tree: $json.treeEntries }) }}",
        "options": {}
      },
      "id": "9208e37e-7b83-4e42-be04-af3b06d30ed4",
      "name": "Create Git Tree",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3888, 16],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare commit with new tree\nconst treeResponse = $input.first().json;\nconst bulkData = $('Extract Tree SHA').first().json;\n\nreturn [{\n  json: {\n    ...bulkData,\n    newTreeSha: treeResponse.sha\n  }\n}];"
      },
      "id": "0c516475-dd2c-43c8-af5b-3342d00c2979",
      "name": "Prepare Commit Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4112, 16]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/commits",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ message: $json.commitMessage, tree: $json.newTreeSha, parents: [$json.baseCommitSha] }) }}",
        "options": {}
      },
      "id": "99958288-1d33-4ffd-8634-1d6671c18557",
      "name": "Create Commit",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4336, 16],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract commit SHA for updating branch reference\nconst commitResponse = $input.first().json;\nconst bulkData = $('Prepare Commit Data').first().json;\n\nreturn [{\n  json: {\n    ...bulkData,\n    newCommitSha: commitResponse.sha\n  }\n}];"
      },
      "id": "197a7e6d-f293-4174-928b-bc0f5f5c51f5",
      "name": "Extract Commit SHA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4560, 16]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/refs/heads/{{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ sha: $json.newCommitSha, force: false }) }}",
        "options": {}
      },
      "id": "d579f90f-b5f6-4faf-a893-e7f21642bd13",
      "name": "Update Branch Reference",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4784, 16],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "model": "anthropic.claude-3-5-sonnet-20241022-v2:0",
        "options": {
          "temperature": 0.3
        }
      },
      "id": "e0b1f6f8-c849-4aad-a641-28923919977b",
      "name": "AWS Bedrock - Individual",
      "type": "@n8n/n8n-nodes-langchain.lmChatAwsBedrock",
      "typeVersion": 1,
      "position": [-872, -352],
      "credentials": {
        "aws": {
          "id": "bYwD2zosP6YYHz0J",
          "name": "AWS account 4"
        }
      }
    },
    {
      "parameters": {
        "model": "anthropic.claude-3-5-sonnet-20241022-v2:0",
        "options": {
          "temperature": 0.3
        }
      },
      "id": "6e8ad978-76e2-492b-b7cd-163963d38271",
      "name": "AWS Bedrock - Batch",
      "type": "@n8n/n8n-nodes-langchain.lmChatAwsBedrock",
      "typeVersion": 1,
      "position": [-872, 152],
      "credentials": {
        "aws": {
          "id": "bYwD2zosP6YYHz0J",
          "name": "AWS account 4"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking 'Test workflow'": {
      "main": [
        [
          {
            "node": "Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Configuration": {
      "main": [
        [
          {
            "node": "Get Branch Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Branch Info": {
      "main": [
        [
          {
            "node": "Get Repository Tree",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Repository Tree": {
      "main": [
        [
          {
            "node": "Process File Structure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process File Structure": {
      "main": [
        [
          {
            "node": "Apply Exclude Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Exclude Patterns": {
      "main": [
        [
          {
            "node": "Route by Processing Mode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Processing Mode": {
      "main": [
        [
          {
            "node": "Split Into Individual Files",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Individual Files": {
      "main": [
        [
          {
            "node": "Fetch File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch File Content": {
      "main": [
        [
          {
            "node": "Prepare Individual File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Individual File": {
      "main": [
        [
          {
            "node": "Prepare Individual File Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Individual File Prompt": {
      "main": [
        [
          {
            "node": "AI - Individual File Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI - Individual File Analysis": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Batches": {
      "main": [
        [
          {
            "node": "Prepare Batch Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batch Prompt": {
      "main": [
        [
          {
            "node": "AI - Batch Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI - Batch Analysis": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge All Results": {
      "main": [
        [
          {
            "node": "Format Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Output": {
      "main": [
        [
          {
            "node": "Export to JSON File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Attach Repo Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Test Files": {
      "main": [
        [
          {
            "node": "Debug Split Item",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Split Item": {
      "main": [
        [
          {
            "node": "Prepare Test File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach Repo Context": {
      "main": [
        [
          {
            "node": "Check Test Branch Once",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Test Branch Once": {
      "main": [
        [
          {
            "node": "Process Branch Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Branch Check": {
      "main": [
        [
          {
            "node": "Need to Create Branch?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need to Create Branch?": {
      "main": [
        [
          {
            "node": "Get Source SHA Once",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Pass Through Existing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Source SHA Once": {
      "main": [
        [
          {
            "node": "Create Branch Once",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Branch Once": {
      "main": [
        [
          {
            "node": "Pass Through After Creation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Through After Creation": {
      "main": [
        [
          {
            "node": "Merge Branch Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Through Existing": {
      "main": [
        [
          {
            "node": "Merge Branch Ready",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Branch Ready": {
      "main": [
        [
          {
            "node": "Debug Before Split",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Before Split": {
      "main": [
        [
          {
            "node": "Split Test Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Test File Content": {
      "main": [
        [
          {
            "node": "Prepare Git Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Commit": {
      "main": [
        [
          {
            "node": "Aggregate All Test Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve Commit Data": {
      "main": [
        [
          {
            "node": "Check If Test Branch Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Test Branch Exists": {
      "main": [
        [
          {
            "node": "Merge Branch Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Branch Check Result": {
      "main": [
        [
          {
            "node": "Branch Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Branch Exists?": {
      "main": [
        [
          {
            "node": "Prepare Branch Creation Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Use Existing Test Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Branch Creation Data": {
      "main": [
        [
          {
            "node": "Get Source Branch SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Source Branch SHA": {
      "main": [
        [
          {
            "node": "Create Test Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Test Branch": {
      "main": [
        [
          {
            "node": "Set Test Branch for Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Test Branch for Commit": {
      "main": [
        [
          {
            "node": "Merge Branch Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Existing Test Branch": {
      "main": [
        [
          {
            "node": "Merge Branch Paths",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Branch Paths": {
      "main": [
        [
          {
            "node": "Aggregate All Test Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate All Test Files": {
      "main": [
        [
          {
            "node": "Get Branch Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Branch Reference": {
      "main": [
        [
          {
            "node": "Extract Base Commit SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Base Commit SHA": {
      "main": [
        [
          {
            "node": "Get Base Tree",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Base Tree": {
      "main": [
        [
          {
            "node": "Extract Tree SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Tree SHA": {
      "main": [
        [
          {
            "node": "Create Git Tree",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Git Tree": {
      "main": [
        [
          {
            "node": "Prepare Commit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Commit Data": {
      "main": [
        [
          {
            "node": "Create Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Commit": {
      "main": [
        [
          {
            "node": "Extract Commit SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Commit SHA": {
      "main": [
        [
          {
            "node": "Update Branch Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AWS Bedrock - Batch": {
      "ai_languageModel": [
        [
          {
            "node": "AI - Batch Analysis",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AWS Bedrock - Individual": {
      "ai_languageModel": [
        [
          {
            "node": "AI - Individual File Analysis",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7d878f67-9f3a-45ef-9bb3-d5c7b772ffbe",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e19bcd79288ba32d5b00c6bcd097856e2fdca4230440ae71d65e560d4587140f"
  },
  "id": "5ThSjB47VE5gPvC3",
  "tags": []
}
