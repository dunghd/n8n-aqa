{
  "name": "GitHub Test Case Generator - Dual Mode (Batch & Individual)",
  "nodes": [
    {
      "parameters": {},
      "id": "a5b140e9-6864-4675-803a-fdefa52fb14e",
      "name": "When clicking 'Test workflow'",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-6016, -64]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "owner",
              "value": "wizeline",
              "type": "string"
            },
            {
              "id": "2",
              "name": "repo",
              "value": "BytescribeTeam",
              "type": "string"
            },
            {
              "id": "3",
              "name": "branch",
              "value": "main",
              "type": "string"
            },
            {
              "id": "4",
              "name": "processingMode",
              "value": "batch",
              "type": "string"
            },
            {
              "id": "5",
              "name": "batchSize",
              "value": 10,
              "type": "number"
            },
            {
              "id": "6",
              "name": "fetchFileContent",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "7",
              "name": "maxFilesToProcess",
              "value": 10,
              "type": "number"
            },
            {
              "id": "8",
              "name": "testBranch",
              "value": "auto-generated-tests",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "a206b113-b0ba-4cd8-b139-ff2e97460e50",
      "name": "Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-5792, -64],
      "notes": "Set processingMode to:\n- 'batch' for faster batch processing\n- 'individual' for detailed file-by-file analysis\n\nSet fetchFileContent to true to get actual code content\nAdjust maxFilesToProcess and batchSize as needed\ntestBranch: branch name for auto-generated test commits"
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/branches/{{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "0921938e-2d2c-4dc9-85e7-6e1c3ad60433",
      "name": "Get Branch Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-5568, -64],
      "credentials": {
        "githubApi": {
          "id": "8iyQGt8qXBNNlcup",
          "name": "GitHub account 4"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $('Configuration').item.json.owner }}/{{ $('Configuration').item.json.repo }}/git/trees/{{ $json.commit.sha }}?recursive=1",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "f46ff996-2049-4487-83f6-026e09ca9e5e",
      "name": "Get Repository Tree",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-5344, -64],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract file tree from GitHub API response\nconst treeData = $input.first().json.tree;\nconst config = $('Configuration').first().json;\nconst owner = config.owner;\nconst repo = config.repo;\nconst branch = config.branch;\nconst maxFiles = config.maxFilesToProcess || 100;\n\n// Define testable file extensions by language/framework\nconst testableExtensions = {\n  javascript: ['.js', '.jsx', '.mjs', '.cjs'],\n  typescript: ['.ts', '.tsx'],\n  python: ['.py'],\n  java: ['.java', '.kt', '.kts'],\n  csharp: ['.cs'],\n  go: ['.go'],\n  ruby: ['.rb'],\n  php: ['.php'],\n  rust: ['.rs'],\n  swift: ['.swift'],\n  cpp: ['.c', '.cpp', '.cc', '.cxx', '.h', '.hpp'],\n  scala: ['.scala'],\n  vue: ['.vue'],\n  svelte: ['.svelte']\n};\n\nconst allTestableExtensions = Object.values(testableExtensions).flat();\n\nconst excludePaths = [\n  'test', 'tests', '__tests__', 'spec', 'specs',\n  'node_modules', 'vendor', 'dist', 'build', 'out',\n  '.git', '.github', '.vscode', '.idea',\n  'coverage', 'docs', 'documentation',\n  'examples', 'demo', 'samples'\n];\n\nconst excludeFilenames = [\n  'jest.config', 'webpack.config', 'babel.config',\n  'tsconfig', 'eslint', 'prettier',\n  '.test.', '.spec.', '_test.', '_spec.',\n  'test.', 'spec.', 'mock', 'fixture'\n];\n\nconst sourceFiles = treeData\n  .filter(item => {\n    if (item.type !== 'blob') return false;\n    \n    const path = item.path.toLowerCase();\n    const filename = path.split('/').pop();\n    \n    const hasTestableExt = allTestableExtensions.some(ext => \n      item.path.endsWith(ext)\n    );\n    if (!hasTestableExt) return false;\n    \n    const isInExcludedPath = excludePaths.some(excluded => \n      path.includes('/' + excluded.toLowerCase() + '/') || \n      path.startsWith(excluded.toLowerCase() + '/')\n    );\n    if (isInExcludedPath) return false;\n    \n    const hasExcludedPattern = excludeFilenames.some(pattern => \n      filename.includes(pattern.toLowerCase())\n    );\n    if (hasExcludedPattern) return false;\n    \n    if (item.size && item.size > 500000) return false;\n    \n    return true;\n  })\n  .slice(0, maxFiles)  // Limit based on config\n  .map(file => {\n    let language = 'unknown';\n    for (const [lang, exts] of Object.entries(testableExtensions)) {\n      if (exts.some(ext => file.path.endsWith(ext))) {\n        language = lang;\n        break;\n      }\n    }\n    \n    return {\n      path: file.path,\n      sha: file.sha,\n      size: file.size,\n      url: file.url,\n      language: language,\n      owner: owner,\n      repo: repo,\n      branch: branch\n    };\n  });\n\nconst filesByLanguage = sourceFiles.reduce((acc, file) => {\n  if (!acc[file.language]) {\n    acc[file.language] = [];\n  }\n  acc[file.language].push(file);\n  return acc;\n}, {});\n\nconst languageStats = Object.entries(filesByLanguage).map(([lang, files]) => ({\n  language: lang,\n  count: files.length,\n  totalSize: files.reduce((sum, f) => sum + (f.size || 0), 0)\n}));\n\nreturn [{\n  json: {\n    owner,\n    repo,\n    branch,\n    processingMode: config.processingMode,\n    fetchFileContent: config.fetchFileContent,\n    batchSize: config.batchSize,\n    totalFiles: treeData.length,\n    sourceFilesCount: sourceFiles.length,\n    sourceFiles: sourceFiles,\n    filesByLanguage: filesByLanguage,\n    languageStats: languageStats,\n    repositoryUrl: `https://github.com/${owner}/${repo}`\n  }\n}];"
      },
      "id": "b43a2679-91bc-4d4a-a04a-0bd5445dfbc5",
      "name": "Process File Structure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-5120, -64]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "mode-check",
              "leftValue": "={{ $json.processingMode }}",
              "rightValue": "individual",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "09e9ff18-5e2c-4f6c-b807-62082135c84b",
      "name": "Route by Processing Mode",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-4896, -64]
    },
    {
      "parameters": {
        "fieldToSplitOut": "sourceFiles",
        "options": {}
      },
      "id": "e5e69146-ecaf-4d38-aec1-b45eed8bdb24",
      "name": "Split Into Individual Files",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [-4672, -176]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/contents/{{ $json.path }}?ref={{ $json.branch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "0c4efe72-28e3-4580-b17d-23e185825a96",
      "name": "Fetch File Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-4448, -176],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Decode base64 content and prepare for AI\nconst item = $input.first().json;\nconst fileInfo = $input.first().json;\n\nlet fileContent = '';\nif (item.content && item.encoding === 'base64') {\n  fileContent = Buffer.from(item.content, 'base64').toString('utf-8');\n}\n\nreturn [{\n  json: {\n    filePath: item.path,\n    fileName: item.name,\n    language: fileInfo.language,\n    size: item.size,\n    content: fileContent,\n    sha: item.sha,\n    owner: fileInfo.owner,\n    repo: fileInfo.repo\n  }\n}];"
      },
      "id": "d9b79d76-781d-48d1-8500-766166ca3ffc",
      "name": "Prepare Individual File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-4224, -176]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "individual-prompt",
              "name": "prompt",
              "value": "=File: {{ $json.filePath }}\nLanguage: {{ $json.language }}\nSize: {{ $json.size }} bytes\n\nFile Content:\n```{{ $json.language }}\n{{ $json.content }}\n```\n\nTask: Generate COMPLETE, EXECUTABLE unit tests for this file. The tests must be production-ready code that can run immediately.\n\nRequirements:\n1. Analyze all functions, classes, and exports in the source file\n2. Generate FULL test code with proper imports, setup, and teardown\n3. Cover happy paths, edge cases, error handling, and boundary conditions\n4. Use appropriate testing framework for {{ $json.language }}\n5. Include necessary mocks for external dependencies\n6. Write tests that actually validate the logic in the source code\n7. Generate COMPLETE test file content - no placeholders or comments like \"add more tests\"\n\nIMPORTANT: Return ONLY valid JSON, no markdown or explanations.\n\nFormat:\n{\n  \"sourceFile\": \"{{ $json.filePath }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"testFile\": \"path/to/test/file\",\n  \"framework\": \"jest|mocha|pytest|junit|etc\",\n  \"testFileContent\": \"COMPLETE executable test code with all imports and test cases\",\n  \"dependencies\": [\"testing-library\", \"mock-library\"],\n  \"coverage\": {\n    \"functions\": [\"function1\", \"function2\"],\n    \"scenarios\": [\"happy path\", \"error cases\", \"edge cases\"]\n  },\n  \"runCommand\": \"command to execute tests\",\n  \"notes\": \"Setup instructions if needed\"\n}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "8d951fbe-f5ba-4f65-b3da-354300086f93",
      "name": "Prepare Individual File Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-4000, -176]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {}
      },
      "id": "c6d9221e-ed31-415c-849e-baafd0ffda35",
      "name": "AI - Individual File Analysis",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [-3776, -176]
    },
    {
      "parameters": {},
      "id": "82b02202-2986-420d-8718-153a6e10e401",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [-3552, -64]
    },
    {
      "parameters": {
        "jsCode": "// Prepare batch processing\nconst data = $input.first().json;\nconst batchSize = data.batchSize || 10;\nconst sourceFiles = data.sourceFiles;\n\n// Create batches\nconst batches = [];\nfor (let i = 0; i < sourceFiles.length; i += batchSize) {\n  batches.push({\n    batchNumber: Math.floor(i / batchSize) + 1,\n    files: sourceFiles.slice(i, i + batchSize),\n    owner: data.owner,\n    repo: data.repo,\n    branch: data.branch,\n    totalBatches: Math.ceil(sourceFiles.length / batchSize)\n  });\n}\n\nreturn batches.map(batch => ({ json: batch }));"
      },
      "id": "a6e2cd5e-7ad4-4f5e-b4fe-95907d4fd31e",
      "name": "Create Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-4672, 48]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "batch-prompt",
              "name": "batchPrompt",
              "value": "=Batch {{ $json.batchNumber }}/{{ $json.totalBatches }}\nRepository: {{ $json.owner }}/{{ $json.repo }}\n\nFiles in this batch:\n{{ $json.files.map(f => `- ${f.path} [${f.language}] (${f.size} bytes)`).join('\\n') }}\n\nTask: Generate COMPLETE, EXECUTABLE unit tests for each file. The tests must be production-ready code that can run immediately.\n\nFor each file:\n1. Infer the likely content and structure based on the file path and language\n2. Generate FULL test code with proper imports, setup, and teardown\n3. Cover common scenarios for files of this type\n4. Use appropriate testing framework\n5. Include necessary mocks\n6. Write COMPLETE test file content - no placeholders\n\nIMPORTANT: Return ONLY a valid JSON array with complete test code.\n\nFormat:\n[\n  {\n    \"sourceFile\": \"path/to/file\",\n    \"language\": \"language\",\n    \"testFile\": \"path/to/test/file\",\n    \"framework\": \"jest|pytest|junit|etc\",\n    \"testFileContent\": \"COMPLETE executable test code\",\n    \"dependencies\": [\"test-deps\"],\n    \"coverage\": {\n      \"functions\": [\"assumed functions\"],\n      \"scenarios\": [\"scenarios covered\"]\n    },\n    \"runCommand\": \"command to run tests\",\n    \"notes\": \"Any setup notes\"\n  }\n]",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "7d3dbc5f-4efc-4c50-872f-42583335cc9f",
      "name": "Prepare Batch Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-4448, 48]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.batchPrompt }}",
        "options": {}
      },
      "id": "396d1b62-a900-4747-8a6e-57935d6d7d21",
      "name": "AI - Batch Analysis",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [-4224, 48]
    },
    {
      "parameters": {
        "jsCode": "// Parse and aggregate batch results\nconst items = $input.all();\nconst repoInfo = $('Process File Structure').first().json;\n\nlet allTestCases = [];\nlet failedItems = [];\n\n// Helper function to convert JS template literals and Python triple quotes to valid JSON\nfunction normalizeToJSON(str) {\n  let normalized = str;\n  \n  // Remove markdown code fences\n  normalized = normalized.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  \n  // Find the array or object structure\n  const arrayMatch = normalized.match(/\\[\\s*{[\\s\\S]*}\\s*\\]/);\n  const targetStr = arrayMatch ? arrayMatch[0] : normalized;\n  \n  // Replace template literals (`...`) with proper JSON strings\n  // This regex finds backtick strings and converts them to double-quoted strings\n  let result = targetStr.replace(/`([^`]*)`/gs, (match, content) => {\n    // Escape special JSON characters in the content\n    const escaped = content\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t');\n    return `\"${escaped}\"`;\n  });\n  \n  // Replace Python triple-quoted strings (\"\"\"...\"\"\") with proper JSON strings\n  result = result.replace(/\"\"\"([^\"]*)?\"\"\"/gs, (match, content) => {\n    const escaped = content\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t');\n    return `\"${escaped}\"`;\n  });\n  \n  // Remove trailing commas before closing braces/brackets\n  result = result.replace(/,\\s*([\\]}])/g, '$1');\n  \n  // Ensure property names are double-quoted\n  result = result.replace(/([{,]\\s*)([a-zA-Z_][a-zA-Z0-9_]*)\\s*:/g, '$1\"$2\":');\n  \n  return result;\n}\n\nitems.forEach((item, itemIndex) => {\n  let output = item.json.output;\n  \n  let testCases;\n  try {\n    // If already an object, use it directly\n    if (typeof output === 'object' && output !== null) {\n      testCases = output;\n    } else if (typeof output === 'string') {\n      // Strategy 1: Try direct JSON parse\n      try {\n        testCases = JSON.parse(output);\n      } catch (parseError) {\n        // Strategy 2: Normalize template literals and triple quotes, then parse\n        try {\n          const normalized = normalizeToJSON(output);\n          testCases = JSON.parse(normalized);\n        } catch (normalizeError) {\n          // Strategy 3: Try to use eval as last resort for JS object literals\n          try {\n            // Extract just the array/object part\n            let cleaned = output.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n            const arrayMatch = cleaned.match(/\\[\\s*{[\\s\\S]*}\\s*\\]/);\n            if (arrayMatch) {\n              // Wrap in parentheses and eval to parse JS object literal\n              testCases = eval(`(${arrayMatch[0]})`);\n            } else {\n              const objectMatch = cleaned.match(/{[\\s\\S]*}/);\n              if (objectMatch) {\n                testCases = eval(`(${objectMatch[0]})`);\n              } else {\n                throw new Error('No valid JSON or JS object pattern found');\n              }\n            }\n          } catch (evalError) {\n            console.error(`Failed to parse item ${itemIndex}:`, evalError.message);\n            failedItems.push({ \n              itemIndex, \n              error: evalError.message, \n              output: output.substring(0, 500),\n              parseAttempts: ['JSON.parse', 'normalizeToJSON', 'eval']\n            });\n            testCases = [];\n          }\n        }\n      }\n    } else {\n      testCases = [];\n    }\n  } catch (e) {\n    console.error(`Error processing item ${itemIndex}:`, e.message);\n    failedItems.push({ itemIndex, error: e.message });\n    testCases = [];\n  }\n  \n  // Ensure testCases is an array\n  if (!Array.isArray(testCases)) {\n    testCases = testCases ? [testCases] : [];\n  }\n  \n  allTestCases = allTestCases.concat(testCases);\n});\n\nconst formattedOutput = {\n  repository: {\n    owner: repoInfo.owner,\n    repo: repoInfo.repo,\n    branch: repoInfo.branch,\n    url: repoInfo.repositoryUrl\n  },\n  processingMode: repoInfo.processingMode,\n  summary: {\n    totalSourceFiles: repoInfo.sourceFilesCount,\n    filesAnalyzed: allTestCases.length,\n    generatedAt: new Date().toISOString(),\n    batchesProcessed: items.length,\n    failedItems: failedItems.length,\n    successfulItems: items.length - failedItems.length\n  },\n  testFiles: allTestCases.map((tc, index) => ({\n    id: index + 1,\n    sourceFile: tc.sourceFile,\n    testFile: tc.testFile,\n    framework: tc.framework || 'jest',\n    language: tc.language,\n    testFileContent: tc.testFileContent || '',\n    dependencies: tc.dependencies || [],\n    coverage: tc.coverage || {},\n    runCommand: tc.runCommand || '',\n    notes: tc.notes || ''\n  })),\n  errors: failedItems.length > 0 ? failedItems : undefined\n};\n\nreturn [{ json: formattedOutput }];"
      },
      "id": "e1856379-fc7b-413a-9cb5-e890b0fc4631",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3328, -64]
    },
    {
      "parameters": {
        "operation": "toJson",
        "options": {
          "fileName": "=github-test-cases-{{ $json.repository.repo }}-{{ $json.processingMode }}-{{ $now.format('yyyy-MM-dd-HHmmss') }}.json"
        }
      },
      "id": "a2e256a3-79d9-47b1-9c1e-cb6cb4da7776",
      "name": "Export to JSON File",
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [-3104, -64]
    },
    {
      "parameters": {
        "jsCode": "// Attach repository context to each testFile entry\nconst formatted = $input.first().json;\nconst repo = formatted.repository || {};\nconst testFiles = formatted.testFiles || [];\nconst enriched = testFiles.map(tf => ({ ...tf, owner: tf.owner || repo.owner, repo: tf.repo || repo.repo, branch: tf.branch || repo.branch }));\nreturn [{ json: { testFiles: enriched } }];"
      },
      "id": "03d43b7b-adb1-44be-9615-97dc0510bcc6",
      "name": "Attach Repo Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3184, 112]
    },
    {
      "parameters": {
        "fieldToSplitOut": "testFiles",
        "options": {}
      },
      "id": "e84e4cf4-29c6-40a9-b8c3-5ab751f265db",
      "name": "Split Test Files",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [-3104, 144]
    },
    {
      "parameters": {
        "operation": "text"
      },
      "id": "43fa097c-8301-4295-983c-38867f007016",
      "name": "Create Test File",
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [-2880, 144]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "data",
              "value": "={{ $json.testFileContent }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "17913fe7-cc87-4e8b-ae51-e8fbe3de4338",
      "name": "Prepare Test File Content",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-2880, 256]
    },
    {
      "parameters": {
        "jsCode": "// Prepare commit payload for GitHub\nconst item = $input.first().json || {};\nconst content = item.testFileContent || item.data || '';\n\n// Get original source filename\nconst sourceFile = item.sourceFile || '';\nlet baseFileName = '';\nif (sourceFile) {\n  const pathParts = sourceFile.split('/');\n  baseFileName = pathParts[pathParts.length - 1];\n  // Remove extension and add test suffix\n  const dotIndex = baseFileName.lastIndexOf('.');\n  if (dotIndex > 0) {\n    const nameWithoutExt = baseFileName.substring(0, dotIndex);\n    const ext = baseFileName.substring(dotIndex);\n    baseFileName = `${nameWithoutExt}.test${ext}`;\n  } else {\n    baseFileName = `${baseFileName}.test`;\n  }\n} else {\n  baseFileName = `generated_test_${Date.now()}.js`;\n}\n\n// Build target path under tests/auto-generated\nconst targetPath = item.testFile || `tests/auto-generated/${baseFileName}`;\n\n// Base64 encode the content\nconst contentBase64 = Buffer.from(content, 'utf8').toString('base64');\n\n// Get owner/repo/branch from item or Configuration node\nlet owner = item.owner || (item.repository && item.repository.owner) || undefined;\nlet repo = item.repo || (item.repository && item.repository.repo) || undefined;\nlet branch = item.branch || (item.repository && item.repository.branch) || undefined;\ntry {\n  const cfg = $('Configuration').first().json || {};\n  owner = owner || cfg.owner || 'unknown-owner';\n  repo = repo || cfg.repo || 'unknown-repo';\n  branch = branch || cfg.branch || 'main';\n} catch (e) {\n  owner = owner || 'unknown-owner';\n  repo = repo || 'unknown-repo';\n  branch = branch || 'main';\n}\n\n// Extract filename for commit message and local export\nconst pathParts = targetPath.split('/');\nconst localFileName = pathParts[pathParts.length - 1];\nconst commitMessage = `chore(tests): add auto-generated test for ${sourceFile || localFileName}`;\n\n// Return data for both GitHub commit and local file creation\nreturn [{ json: { owner, repo, branch, targetPath, contentBase64, commitMessage, testFile: item.testFile, testFileContent: content, data: content, localFileName } }];"
      },
      "id": "006b6ce6-c62b-4083-b3d0-f3584df3bd83",
      "name": "Prepare Git Commit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2640, 256]
    },
    {
      "parameters": {
        "jsCode": "// Preserve commit data and prepare for branch check\nconst commitData = $input.first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...commitData,\n    testBranch: config.testBranch,\n    checkBranchUrl: `https://api.github.com/repos/${commitData.owner}/${commitData.repo}/branches/${config.testBranch}`\n  }\n}];"
      },
      "id": "be49f55a-0d24-4185-89ce-e25838989bfe",
      "name": "Preserve Commit Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2416, 256]
    },
    {
      "parameters": {
        "url": "={{ $json.checkBranchUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {
          "allowUnauthorizedCerts": false
        }
      },
      "id": "b2bc2715-e2ba-49c1-bbe6-ebf506cdc858",
      "name": "Check If Test Branch Exists",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-2192, 256],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Merge the branch check result with commit data\nconst branchCheckResult = $input.first().json;\nconst commitData = $('Preserve Commit Data').first().json;\n\n// Check if the request failed (error property exists) or succeeded\nconst hasError = branchCheckResult.error !== undefined;\nconst statusCode = branchCheckResult.statusCode || (hasError ? 404 : 200);\nconst branchExists = !hasError && statusCode === 200;\n\nreturn [{\n  json: {\n    ...commitData,\n    branchExists: branchExists,\n    statusCode: statusCode\n  }\n}];"
      },
      "id": "658d7a2b-1800-4294-bf95-5cd283d3a38b",
      "name": "Merge Branch Check Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1968, 256]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "branch-exists-check",
              "leftValue": "={{ $json.branchExists }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "2c0b1a71-1d78-4a98-b0d1-b045e5a0a639",
      "name": "Branch Exists?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-1744, 256]
    },
    {
      "parameters": {
        "jsCode": "// Get the latest commit SHA from the main branch to create new branch from it\nconst data = $input.first().json;\nconst prepareCommitData = $('Prepare Git Commit').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    owner: prepareCommitData.owner,\n    repo: prepareCommitData.repo,\n    sourceBranch: config.branch,\n    testBranch: config.testBranch,\n    ...prepareCommitData\n  }\n}];"
      },
      "id": "bf3ea752-2767-4212-a0d5-af2a33f1ba0a",
      "name": "Prepare Branch Creation Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1520, 144]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/git/ref/heads/{{ $json.sourceBranch }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {}
      },
      "id": "76fac991-2617-4e17-af22-fc7f1908dd59",
      "name": "Get Source Branch SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-1296, 144],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.github.com/repos/{{ $('Prepare Branch Creation Data').first().json.owner }}/{{ $('Prepare Branch Creation Data').first().json.repo }}/git/refs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ ref: 'refs/heads/' + $('Prepare Branch Creation Data').first().json.testBranch, sha: $json.object.sha }) }}",
        "options": {}
      },
      "id": "68a20b50-8f2d-4934-84aa-538b31a90a04",
      "name": "Create Test Branch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-1072, 144],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge the branch creation result with the commit data\nconst prepareCommitData = $('Prepare Git Commit').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...prepareCommitData,\n    branch: config.testBranch  // Override branch to use test branch\n  }\n}];"
      },
      "id": "2bb3ba4d-0fce-4ddb-813d-f36699216f76",
      "name": "Set Test Branch for Commit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-848, 144]
    },
    {
      "parameters": {
        "jsCode": "// For existing branch, just pass through with test branch override\nconst prepareCommitData = $('Preserve Commit Data').first().json;\nconst config = $('Configuration').first().json;\n\nreturn [{\n  json: {\n    ...prepareCommitData,\n    branch: config.testBranch  // Override branch to use test branch\n  }\n}];"
      },
      "id": "47fa7f65-4ef8-4aa3-8401-43b147574502",
      "name": "Use Existing Test Branch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1520, 368]
    },
    {
      "parameters": {},
      "id": "7fbf8376-fd7d-4fd3-9b89-e91720409bf9",
      "name": "Merge Branch Paths",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [-624, 256]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://api.github.com/repos/{{ $json.owner }}/{{ $json.repo }}/contents/{{ $json.targetPath }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ message: $json.commitMessage, content: $json.contentBase64, branch: $json.branch }) }}",
        "options": {}
      },
      "id": "05b85779-3418-4830-9f79-e967732197ac",
      "name": "Create/Update File on GitHub",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-400, 256],
      "credentials": {
        "githubApi": {
          "id": "74FBfZyE3yFXYmu7",
          "name": "GitHub account 5"
        }
      }
    },
    {
      "parameters": {
        "model": "anthropic.claude-3-5-sonnet-20241022-v2:0",
        "options": {
          "temperature": 0.3
        }
      },
      "id": "2b724c15-5047-41a3-813f-33e8df553410",
      "name": "AWS Bedrock - Individual",
      "type": "@n8n/n8n-nodes-langchain.lmChatAwsBedrock",
      "typeVersion": 1,
      "position": [-3776, 80],
      "credentials": {
        "aws": {
          "id": "bYwD2zosP6YYHz0J",
          "name": "AWS account 4"
        }
      }
    },
    {
      "parameters": {
        "model": "anthropic.claude-3-5-sonnet-20241022-v2:0",
        "options": {
          "temperature": 0.3
        }
      },
      "id": "c44c9dd9-f4e2-4a6c-a4e2-89e3f9634f9a",
      "name": "AWS Bedrock - Batch",
      "type": "@n8n/n8n-nodes-langchain.lmChatAwsBedrock",
      "typeVersion": 1,
      "position": [-4224, 256],
      "credentials": {
        "aws": {
          "id": "bYwD2zosP6YYHz0J",
          "name": "AWS account 4"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking 'Test workflow'": {
      "main": [
        [
          {
            "node": "Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Configuration": {
      "main": [
        [
          {
            "node": "Get Branch Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Branch Info": {
      "main": [
        [
          {
            "node": "Get Repository Tree",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Repository Tree": {
      "main": [
        [
          {
            "node": "Process File Structure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process File Structure": {
      "main": [
        [
          {
            "node": "Route by Processing Mode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Processing Mode": {
      "main": [
        [
          {
            "node": "Split Into Individual Files",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Individual Files": {
      "main": [
        [
          {
            "node": "Fetch File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch File Content": {
      "main": [
        [
          {
            "node": "Prepare Individual File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Individual File": {
      "main": [
        [
          {
            "node": "Prepare Individual File Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Individual File Prompt": {
      "main": [
        [
          {
            "node": "AI - Individual File Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI - Individual File Analysis": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Batches": {
      "main": [
        [
          {
            "node": "Prepare Batch Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batch Prompt": {
      "main": [
        [
          {
            "node": "AI - Batch Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI - Batch Analysis": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge All Results": {
      "main": [
        [
          {
            "node": "Format Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Output": {
      "main": [
        [
          {
            "node": "Export to JSON File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Attach Repo Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Test Files": {
      "main": [
        [
          {
            "node": "Prepare Test File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach Repo Context": {
      "main": [
        [
          {
            "node": "Split Test Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Test File Content": {
      "main": [
        [
          {
            "node": "Prepare Git Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Commit": {
      "main": [
        [
          {
            "node": "Preserve Commit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve Commit Data": {
      "main": [
        [
          {
            "node": "Check If Test Branch Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Test Branch Exists": {
      "main": [
        [
          {
            "node": "Merge Branch Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Branch Check Result": {
      "main": [
        [
          {
            "node": "Branch Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Branch Exists?": {
      "main": [
        [
          {
            "node": "Prepare Branch Creation Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Use Existing Test Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Branch Creation Data": {
      "main": [
        [
          {
            "node": "Get Source Branch SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Source Branch SHA": {
      "main": [
        [
          {
            "node": "Create Test Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Test Branch": {
      "main": [
        [
          {
            "node": "Set Test Branch for Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Test Branch for Commit": {
      "main": [
        [
          {
            "node": "Merge Branch Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Existing Test Branch": {
      "main": [
        [
          {
            "node": "Merge Branch Paths",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Branch Paths": {
      "main": [
        [
          {
            "node": "Create/Update File on GitHub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create/Update File on GitHub": {
      "main": [
        [
          {
            "node": "Create Test File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AWS Bedrock - Batch": {
      "ai_languageModel": [
        [
          {
            "node": "AI - Batch Analysis",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AWS Bedrock - Individual": {
      "ai_languageModel": [
        [
          {
            "node": "AI - Individual File Analysis",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ab8b1de9-bdd8-491c-ae68-d5615725cbae",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e19bcd79288ba32d5b00c6bcd097856e2fdca4230440ae71d65e560d4587140f"
  },
  "id": "5ThSjB47VE5gPvC3",
  "tags": []
}
